<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Hound<br> ELINT for DCS</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Tables">Tables</a></li>
<li><a href="#General_functions">General functions </a></li>
<li><a href="#Value_mapping_Functions">Value mapping Functions </a></li>
<li><a href="#Geo_Function">Geo Function </a></li>
<li><a href="#Marker_Functions">Marker Functions </a></li>
<li><a href="#HOUND_Utils_Marker_instance">HOUND.Utils.Marker.instance</a></li>
<li><a href="#TTS_Functions">TTS Functions </a></li>
<li><a href="#Text_Functions">Text Functions </a></li>
<li><a href="#Elint_functions">Elint functions </a></li>
<li><a href="#Vector_functions">Vector functions </a></li>
<li><a href="#Zone_functions">Zone functions </a></li>
<li><a href="#Polygon_functions">Polygon functions </a></li>
<li><a href="#Clustering_algorithems__for_future_use_">Clustering algorithems (for future use) </a></li>
<li><a href="#Sort_Functions">Sort Functions </a></li>
<li><a href="#Filter_Functions">Filter Functions </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/HOUND.html">HOUND</a></li>
  <li><a href="../modules/HOUND.Logger.html">HOUND.Logger</a></li>
  <li><a href="../modules/HOUND.DBs.html">HOUND.DBs</a></li>
  <li><a href="../modules/HOUND.Config.html">HOUND.Config</a></li>
  <li><strong>HOUND.Utils</strong></li>
  <li><a href="../modules/HOUND.EventHandler.html">HOUND.EventHandler</a></li>
  <li><a href="../modules/HOUND.Estimator.html">HOUND.Estimator</a></li>
  <li><a href="../modules/HOUND.Datapoint.html">HOUND.Datapoint</a></li>
  <li><a href="../modules/HOUND.Contact.html">HOUND.Contact</a></li>
  <li><a href="../modules/HOUND.Comms.Manager.html">HOUND.Comms.Manager</a></li>
  <li><a href="../modules/HOUND.Comms.InformationSystem.html">HOUND.Comms.InformationSystem</a></li>
  <li><a href="../modules/HOUND.Comms.Controller.html">HOUND.Comms.Controller</a></li>
  <li><a href="../modules/HOUND.Comms.Notifier.html">HOUND.Comms.Notifier</a></li>
  <li><a href="../modules/HOUND.ElintWorker.html">HOUND.ElintWorker</a></li>
  <li><a href="../modules/HOUND.ContactManager.html">HOUND.ContactManager</a></li>
  <li><a href="../modules/HOUND.Sector.html">HOUND.Sector</a></li>
</ul>
<h2>Scripts</h2>
<ul class="nowrap">
  <li><a href="../scripts/HoundElint.html">HoundElint</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>HOUND.Utils</code></h1>
<p>HOUND.Utils
 This class holds generic function used by all of Hound Components</p>
<p></p>


<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils">HOUND.Utils</a></td>
	<td class="summary">HOUND.Utils decleration</td>
	</tr>
</table>
<h2><a href="#General_functions">General functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getHoundId">HOUND.Utils.getHoundId ()</a></td>
	<td class="summary">get next Hound Instance Id</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getMarkId">HOUND.Utils.getMarkId ()</a></td>
	<td class="summary">Get next Markpoint Id (Depricated)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.setInitialMarkId">HOUND.Utils.setInitialMarkId (startId)</a></td>
	<td class="summary">Set New initial marker Id (DEPRICATED)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.absTimeDelta">HOUND.Utils.absTimeDelta (t0[, t1])</a></td>
	<td class="summary">Get time delta between two timestemps</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.angleDeltaRad">HOUND.Utils.angleDeltaRad (rad1, rad2)</a></td>
	<td class="summary">return difference in radias between two angles (bearings)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.AzimuthAverage">HOUND.Utils.AzimuthAverage (azimuths)</a></td>
	<td class="summary">return avarage azimuth</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.PointClusterTilt">HOUND.Utils.PointClusterTilt (points[, MagNorth[, refPos]])</a></td>
	<td class="summary">return the tilt of a point cluster</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.RandomAngle">HOUND.Utils.RandomAngle ()</a></td>
	<td class="summary">returns a random angle</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getSamMaxRange">HOUND.Utils.getSamMaxRange (DCS_Unit)</a></td>
	<td class="summary">return maximum weapon range in the group of DCS Unit</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getRadarDetectionRange">HOUND.Utils.getRadarDetectionRange (DCS_Unit)</a></td>
	<td class="summary">return Radar detection Range for provided unit</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getRoundedElevationFt">HOUND.Utils.getRoundedElevationFt (elev[, resolution])</a></td>
	<td class="summary">return ground elevation rouded to 50 feet</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.roundToNearest">HOUND.Utils.roundToNearest (input, nearest)</a></td>
	<td class="summary">return rounted number nearest a set interval</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getNormalAngularError">HOUND.Utils.getNormalAngularError (variance)</a></td>
	<td class="summary">get normal distribution angular error.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getControllerResponse">HOUND.Utils.getControllerResponse ()</a></td>
	<td class="summary">get random controller snarky remark</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getCoalitionString">HOUND.Utils.getCoalitionString (coalitionID)</a></td>
	<td class="summary">get coalition string</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getHemispheres">HOUND.Utils.getHemispheres (lat, lon, fullText)</a></td>
	<td class="summary">returns hemisphere information for LatLon</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getReportId">HOUND.Utils.getReportId ([ReportId])</a></td>
	<td class="summary">get "ATIS" report ID
 returns next Phonetic report ID.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.DecToDMS">HOUND.Utils.DecToDMS (cood)</a></td>
	<td class="summary">Convert Decimal Degrees to DMS (D.DD to DMS)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getBR">HOUND.Utils.getBR (src, dst)</a></td>
	<td class="summary">retrun Bearing (magnetic) and range between two points</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getFormationCallsign">HOUND.Utils.getFormationCallsign (player[, flightMember])</a></td>
	<td class="summary">Get group callsign from unit</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.getHoundCallsign">HOUND.Utils.getHoundCallsign ([namePool])</a></td>
	<td class="summary">get Callsign</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.isDMM">HOUND.Utils.isDMM (DCS_Unit)</a></td>
	<td class="summary">Unit use DMM</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.hasPayload">HOUND.Utils.hasPayload (DCS_Unit, payloadName)</a></td>
	<td class="summary">does unit has payload (placeholder)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.hasTask">HOUND.Utils.hasTask (DCS_Unit, taskName)</a></td>
	<td class="summary">does unit has task (placeholder)</td>
	</tr>
</table>
<h2><a href="#Value_mapping_Functions">Value mapping Functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Mapping.linear">HOUND.Utils.Mapping.linear (input, in_min, in_max, out_min, out_max[, clamp])</a></td>
	<td class="summary">map input to range (Arduino implementation)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Mapping.nonLinear">HOUND.Utils.Mapping.nonLinear (value, in_min, in_max[, out_min[, out_max[, sensitivity[, curve_type]]]])</a></td>
	<td class="summary">Map values on a curve</td>
	</tr>
</table>
<h2><a href="#Geo_Function">Geo Function </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Geo.checkLOS">HOUND.Utils.Geo.checkLOS (pos0, pos1)</a></td>
	<td class="summary">Return if the is LOS between two DCS points
 checks both radar horizon (round earth) and DCS terrain LOS</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Geo.EarthLOS">HOUND.Utils.Geo.EarthLOS (h0[, h1])</a></td>
	<td class="summary">Returns maximum horizon distance given heigh above the earth of two points
 if only one observer hight is provided, result would be maximum view distance to Sea Level</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Geo.isDcsPoint">HOUND.Utils.Geo.isDcsPoint (point)</a></td>
	<td class="summary">check if point is DCS point</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Geo.getProjectedIP">HOUND.Utils.Geo.getProjectedIP (p0, az, el)</a></td>
	<td class="summary">Returns Projected line impact point with Terrain</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Geo.setPointHeight">HOUND.Utils.Geo.setPointHeight (point)</a></td>
	<td class="summary">Ensure Inpoint DCS point has Elevation</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Geo.setHeight">HOUND.Utils.Geo.setHeight (point)</a></td>
	<td class="summary">Ensure input point or point table all have valid Elevation</td>
	</tr>
</table>
<h2><a href="#Marker_Functions">Marker Functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Marker.getId">HOUND.Utils.Marker.getId ()</a></td>
	<td class="summary">Get next Markpoint Id</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Marker.setInitialId">HOUND.Utils.Marker.setInitialId (startId)</a></td>
	<td class="summary">Set New initial marker Id</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Marker.create">HOUND.Utils.Marker.create ([args])</a></td>
	<td class="summary">create Marker entity</td>
	</tr>
</table>
<h2><a href="#HOUND_Utils_Marker_instance">HOUND.Utils.Marker.instance</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#instance.setPos">instance.setPos (self, pos)</a></td>
	<td class="summary">update markpoint position</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance.setText">instance.setText (self, text)</a></td>
	<td class="summary">update markpoint text</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance.setRadius">instance.setRadius (self, radius)</a></td>
	<td class="summary">update markpoint radius</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance.setFillColor">instance.setFillColor (self, color)</a></td>
	<td class="summary">update markpoint fill color</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance.setLineColor">instance.setLineColor (self, color)</a></td>
	<td class="summary">update markpoint line color</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance.isDrawn">instance.isDrawn (self)</a></td>
	<td class="summary">Check if marpoint is drawn</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance.remove">instance.remove (self)</a></td>
	<td class="summary">remove markpoint</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance._new">instance._new (self, args)</a></td>
	<td class="summary">create new point (internal)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance._replace">instance._replace (self, args)</a></td>
	<td class="summary">replace markpoint (internal)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#instance.update">instance.update (self, args)</a></td>
	<td class="summary">update markpoint</td>
	</tr>
</table>
<h2><a href="#TTS_Functions">TTS Functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.TTS.Transmit">HOUND.Utils.TTS.Transmit (msg, coalitionID, args[, transmitterPos])</a></td>
	<td class="summary">Transmit message using STTS (private)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.TTS.getTtsTime">HOUND.Utils.TTS.getTtsTime ([timestamp])</a></td>
	<td class="summary">returns current DCS time in military time string for TTS</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.TTS.getVerbalConfidenceLevel">HOUND.Utils.TTS.getVerbalConfidenceLevel (confidenceRadius)</a></td>
	<td class="summary">return verbal accuracy description
 in 500 meters interval</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.TTS.getVerbalContactAge">HOUND.Utils.TTS.getVerbalContactAge (timestamp[, isSimple[, NATO]])</a></td>
	<td class="summary">Get Verbal description of contact age
 has multiple "modes of operation"</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.TTS.getVerbalLL">HOUND.Utils.TTS.getVerbalLL (lat, lon[, minDec])</a></td>
	<td class="summary">convert LL to TTS string</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.TTS.toPhonetic">HOUND.Utils.TTS.toPhonetic (str)</a></td>
	<td class="summary">Convert string to phonetic text</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.TTS.getReadTime">HOUND.Utils.TTS.getReadTime (length[, speed[, isGoogle]])</a></td>
	<td class="summary">get estimated message read time
 returns estimated time in seconds STTS will need to read a message</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.TTS.simplfyDistance">HOUND.Utils.TTS.simplfyDistance (distanceM)</a></td>
	<td class="summary">simplify distance</td>
	</tr>
</table>
<h2><a href="#Text_Functions">Text Functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Text.getLL">HOUND.Utils.Text.getLL (lat, lon[, minDec])</a></td>
	<td class="summary">convert LL to displayable string</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Text.getTime">HOUND.Utils.Text.getTime ([timestamp])</a></td>
	<td class="summary">Text Function - returns current DCS time in military time format string</td>
	</tr>
</table>
<h2><a href="#Elint_functions">Elint functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.getDefraction">HOUND.Utils.Elint.getDefraction (band, antenna_size)</a></td>
	<td class="summary">Get defraction
 for band and effective antenna size return angular resolution</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.getApertureSize">HOUND.Utils.Elint.getApertureSize (DCS_Unit)</a></td>
	<td class="summary">get Effective Aperture size for unit</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.getEmitterBand">HOUND.Utils.Elint.getEmitterBand (DCS_Unit)</a></td>
	<td class="summary">Get emitter Band</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.getSensorPrecision">HOUND.Utils.Elint.getSensorPrecision (platform, emitterBand)</a></td>
	<td class="summary">Elint Function - Get sensor precision</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.generateAngularError">HOUND.Utils.Elint.generateAngularError (variance)</a></td>
	<td class="summary">Elint Function - Generate angular error</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.getAzimuth">HOUND.Utils.Elint.getAzimuth (src, dst, sensorPrecision)</a></td>
	<td class="summary">Get Azimuth (and elevation) between two points</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.getActiveRadars">HOUND.Utils.Elint.getActiveRadars (instanceCoalition)</a></td>
	<td class="summary">Get currently transmitting Ground and Ship radars that are not in the Hound Instance coalition</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.getRwrContacts">HOUND.Utils.Elint.getRwrContacts (platform)</a></td>
	<td class="summary">Get RWR contacts for platfom</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Elint.isValidPlatform">HOUND.Utils.Elint.isValidPlatform (candidate)</a></td>
	<td class="summary">check if canidate Object is a valid platform</td>
	</tr>
</table>
<h2><a href="#Vector_functions">Vector functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Vector.getUnitVector">HOUND.Utils.Vector.getUnitVector (Theta[, Phi])</a></td>
	<td class="summary">get UnitVector</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Vector.getRandomVec2">HOUND.Utils.Vector.getRandomVec2 (variance)</a></td>
	<td class="summary">Get random 2D vector
 use Box–Muller transform to randomize errors on 2D vector
 https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform}</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Vector.getRandomVec3">HOUND.Utils.Vector.getRandomVec3 (variance)</a></td>
	<td class="summary">Get random 3d vector
 use Box–Muller transform to randomize errors on 3D vector
 https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform}</td>
	</tr>
</table>
<h2><a href="#Zone_functions">Zone functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Zone.listDrawnZones">HOUND.Utils.Zone.listDrawnZones ()</a></td>
	<td class="summary">List all Useable zones from drawings.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Zone.getDrawnZone">HOUND.Utils.Zone.getDrawnZone (zoneName)</a></td>
	<td class="summary">Get zone from drawing\
 (supported types are freeForm Polygon, rectangle and Oval)</td>
	</tr>
</table>
<h2><a href="#Polygon_functions">Polygon functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Polygon.threatOnSector">HOUND.Utils.Polygon.threatOnSector (polygon, point, radius)</a></td>
	<td class="summary">Check if polygon is under threat of SAM</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Polygon.filterPointsByPolygon">HOUND.Utils.Polygon.filterPointsByPolygon (points, polygon)</a></td>
	<td class="summary">Filter out points not in polygon</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Polygon.clipPolygons">HOUND.Utils.Polygon.clipPolygons (subjectPolygon, clipPolygon)</a></td>
	<td class="summary">calculate cliping of polygons
 <a href="https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#Lua">Sutherland-Hodgman polygon clipping</a></td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Polygon.giftWrap">HOUND.Utils.Polygon.giftWrap (points)</a></td>
	<td class="summary">Gift wrapping algorithem
 Returns the convex hull (using <a href="http://en.wikipedia.org/wiki/Gift_wrapping_algorithm">Jarvis' Gift wrapping algorithm</a>).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Polygon.circumcirclePoints">HOUND.Utils.Polygon.circumcirclePoints (points)</a></td>
	<td class="summary">calculate Smallest circle around point cloud
 Welzel algorithm for <a href="https://en.wikipedia.org/wiki/Smallest-circle_problem">Smallest-circle problem</a>
 Implementation taken from <a href="https://github.com/rowanwins/smallest-enclosing-circle/blob/master/src/main.js">github/rowins</a></td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Polygon.getArea">HOUND.Utils.Polygon.getArea (polygon)</a></td>
	<td class="summary">return the area of a convex polygon</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Polygon.clipOrHull">HOUND.Utils.Polygon.clipOrHull (polyA, polyB)</a></td>
	<td class="summary">clip or hull two polygons</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Polygon.azMinMax">HOUND.Utils.Polygon.azMinMax (poly, refPos)</a></td>
	<td class="summary">find min/max azimuth</td>
	</tr>
</table>
<h2><a href="#Clustering_algorithems__for_future_use_">Clustering algorithems (for future use) </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Cluster.gaussianKernel">HOUND.Utils.Cluster.gaussianKernel (value, bandwidth)</a></td>
	<td class="summary">Get gaussian weight</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Cluster.stdDev">HOUND.Utils.Cluster.stdDev ()</a></td>
	<td class="summary">Calculate running std dev</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Cluster.weightedMean">HOUND.Utils.Cluster.weightedMean (origPoints[, initPos[, threashold[, maxIttr]]])</a></td>
	<td class="summary">find the weighted mean of a points cluster (meanShift)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Cluster.kmeans">HOUND.Utils.Cluster.kmeans (data, nclusters, init)</a></td>
	<td class="summary">K-means++ algorithm
 <a href=https://rosettacode.org/wiki/K-means%2B%2B_clustering#Lua>Source of implementation</a></td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#contacts">contacts</a></td>
	<td class="summary">convert contacts to centroieds for meanShift</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#contacts">contacts</a></td>
	<td class="summary">Mean-shift algorithem to group radars to sites
 http://www.chioka.in/meanshift-algorithm-for-the-rest-of-us-python/</td>
	</tr>
</table>
<h2><a href="#Sort_Functions">Sort Functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Sort.ContactsByRange">HOUND.Utils.Sort.ContactsByRange (a, b)</a></td>
	<td class="summary">Sort contacts by engament range</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Sort.ContactsById">HOUND.Utils.Sort.ContactsById (a, b)</a></td>
	<td class="summary">Sort contacts by ID</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Sort.sectorsByPriorityLowFirst">HOUND.Utils.Sort.sectorsByPriorityLowFirst (a, b)</a></td>
	<td class="summary">sort sectors by priority (low first)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Sort.sectorsByPriorityLowLast">HOUND.Utils.Sort.sectorsByPriorityLowLast (a, b)</a></td>
	<td class="summary">sort sectors by priority (Low last)</td>
	</tr>
</table>
<h2><a href="#Filter_Functions">Filter Functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Filter.groupsByPrefix">HOUND.Utils.Filter.groupsByPrefix (prefix)</a></td>
	<td class="summary">get Groups by prefix
 Implementation taken from Skynet-IADS</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Filter.unitsByPrefix">HOUND.Utils.Filter.unitsByPrefix (prefix)</a></td>
	<td class="summary">get Units by prefix
 Implementation taken from Skynet-IADS</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HOUND.Utils.Filter.staticObjectsByPrefix">HOUND.Utils.Filter.staticObjectsByPrefix (prefix)</a></td>
	<td class="summary">get StatcObjects by prefix
 Implementation taken from Skynet-IADS</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils"></a>
    <strong>HOUND.Utils</strong>
    </dt>
    <dd>
    HOUND.Utils decleration


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">Mapping</span>
         Extrapulation functions
        </li>
        <li><span class="parameter">Geo</span>
         Geographic functions
        </li>
        <li><span class="parameter">TTS</span>
         TTS Functions
        </li>
        <li><span class="parameter">Text</span>
         Text functions
        </li>
        <li><span class="parameter">Elint</span>
         Elint functions
        </li>
        <li><span class="parameter">Sort</span>
         Sort funtions
        </li>
        <li><span class="parameter">Filter</span>
         Filter functions
        </li>
        <li><span class="parameter">ReportId</span>
         intrnal ATIS numerator
        </li>
        <li><span class="parameter">_MarkId</span>
         internal markId Counter
        </li>
        <li><span class="parameter">_HoundId</span>
         internal HoundId counter
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="General_functions"></a>General functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.getHoundId"></a>
    <strong>HOUND.Utils.getHoundId ()</strong>
    </dt>
    <dd>
    get next Hound Instance Id



    <h3>Returns:</h3>
    <ol>

        #number Next HoundId
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getMarkId"></a>
    <strong>HOUND.Utils.getMarkId ()</strong>
    </dt>
    <dd>
    Get next Markpoint Id (Depricated)



    <h3>Returns:</h3>
    <ol>

        Next MarkId
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="../modules/HOUND.Utils.html#HOUND.Utils.Marker.getId">HOUND.Utils.Marker.getId</a>
    </ul>


</dd>
    <dt>
    <a name = "HOUND.Utils.setInitialMarkId"></a>
    <strong>HOUND.Utils.setInitialMarkId (startId)</strong>
    </dt>
    <dd>
    Set New initial marker Id (DEPRICATED)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">startId</span>
         Number to start counting from
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool True if initial ID was updated
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="../modules/HOUND.Utils.html#HOUND.Utils.Marker.setInitialId">HOUND.Utils.Marker.setInitialId</a>
    </ul>


</dd>
    <dt>
    <a name = "HOUND.Utils.absTimeDelta"></a>
    <strong>HOUND.Utils.absTimeDelta (t0[, t1])</strong>
    </dt>
    <dd>
    Get time delta between two timestemps


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t0</span>
         time to test (in number of seconds)
        </li>
        <li><span class="parameter">t1</span>
         time in number of seconds. if not provided, will use current DCS mission time
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        time delta between t0 and t1
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">HOUND.Utils.absTimeDelta(&lt;<span class="number">10</span>s ago&gt;,now) ==&gt; <span class="number">10</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "HOUND.Utils.angleDeltaRad"></a>
    <strong>HOUND.Utils.angleDeltaRad (rad1, rad2)</strong>
    </dt>
    <dd>
    return difference in radias between two angles (bearings)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">rad1</span>
         angle in radians
        </li>
        <li><span class="parameter">rad2</span>
         angle in radians
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        angle difference between rad1 and rad2 (between pi and -pi)
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.AzimuthAverage"></a>
    <strong>HOUND.Utils.AzimuthAverage (azimuths)</strong>
    </dt>
    <dd>
    return avarage azimuth


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">azimuths</span>
         a list of azimuths in radians
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the avarage azimuth of the list provided in radians (between 0 and 2*pi)
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.PointClusterTilt"></a>
    <strong>HOUND.Utils.PointClusterTilt (points[, MagNorth[, refPos]])</strong>
    </dt>
    <dd>
    return the tilt of a point cluster


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">points</span>
         a list of DCS points
        </li>
        <li><span class="parameter">MagNorth</span>
         (Bool) if true value will include north var correction
         (<em>optional</em>)
        </li>
        <li><span class="parameter">refPos</span>
         a DCS point that will be the reference for azimuth
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        azimuth in radians (between 0 and pi)
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.RandomAngle"></a>
    <strong>HOUND.Utils.RandomAngle ()</strong>
    </dt>
    <dd>
    returns a random angle



    <h3>Returns:</h3>
    <ol>

        random angle in radians between 0 and 2*pi
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getSamMaxRange"></a>
    <strong>HOUND.Utils.getSamMaxRange (DCS_Unit)</strong>
    </dt>
    <dd>
    return maximum weapon range in the group of DCS Unit


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">DCS_Unit</span>
         DCS unit - in Hound context unit with emitting radar
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        maximum weapon range in meters of the DCS Group the emitter is part of
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getRadarDetectionRange"></a>
    <strong>HOUND.Utils.getRadarDetectionRange (DCS_Unit)</strong>
    </dt>
    <dd>
    return Radar detection Range for provided unit


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">DCS_Unit</span>
         DCS Unit with radars sensor
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Unit radar detection range agains airborne targers in meters
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getRoundedElevationFt"></a>
    <strong>HOUND.Utils.getRoundedElevationFt (elev[, resolution])</strong>
    </dt>
    <dd>
    return ground elevation rouded to 50 feet


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">elev</span>
         Height in meters
        </li>
        <li><span class="parameter">resolution</span>
         round to the nerest increment. default is 50
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        elevation converted to feet, rounded to the nearest 50 ft
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.roundToNearest"></a>
    <strong>HOUND.Utils.roundToNearest (input, nearest)</strong>
    </dt>
    <dd>
    return rounted number nearest a set interval


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">input</span>
         numeric value to be rounded
        </li>
        <li><span class="parameter">nearest</span>
         numeric value of the step to round input to (e.g 10,50,500)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        input number rounded to the nearest interval provided.(e.g 3244 -> 3250)
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getNormalAngularError"></a>
    <strong>HOUND.Utils.getNormalAngularError (variance)</strong>
    </dt>
    <dd>
    get normal distribution angular error.
 will generate gaussian magnitude based on variance and random angle


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">variance</span>
         error margin requester (in radians)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table {el,az}, contining error in Azimuth and elevation in radians
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getControllerResponse"></a>
    <strong>HOUND.Utils.getControllerResponse ()</strong>
    </dt>
    <dd>
    get random controller snarky remark



    <h3>Returns:</h3>
    <ol>

        random response string from pool
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getCoalitionString"></a>
    <strong>HOUND.Utils.getCoalitionString (coalitionID)</strong>
    </dt>
    <dd>
    get coalition string


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">coalitionID</span>
         integer of DCS coalition id
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string name of coalition
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getHemispheres"></a>
    <strong>HOUND.Utils.getHemispheres (lat, lon, fullText)</strong>
    </dt>
    <dd>
    returns hemisphere information for LatLon


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">lat</span>
         (float) latitude in decimal Degrees
        </li>
        <li><span class="parameter">lon</span>
         (float) longitude in decimal Degrees
        </li>
        <li><span class="parameter">fullText</span>
         (bool) determin if function should return "E" or "East"
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        (table) {NS=string,EW=string} return hemisphere strings
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getReportId"></a>
    <strong>HOUND.Utils.getReportId ([ReportId])</strong>
    </dt>
    <dd>
    get "ATIS" report ID
 returns next Phonetic report ID.
 Report ID loops around, i.e "Alpha" --> "Bravo" -> .. -> "Zulu" -> "Alpha"


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ReportId</span>
         char, current report ID if not using global var
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        (string) phonetic ID ("Alpha","Bravo", "charlie"...)</li>
        <li>
        (Char) letter of ReportId ('A','B','C','D')</li>
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.DecToDMS"></a>
    <strong>HOUND.Utils.DecToDMS (cood)</strong>
    </dt>
    <dd>
    Convert Decimal Degrees to DMS (D.DD to DMS)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cood</span>
         (float) lat or lon (e.g. 35.443, -124.5543)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

         DMS (table)
 { d=deg,
   m=minutes,
   s=sec,
   mDec = Decimal minutes
 }
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getBR"></a>
    <strong>HOUND.Utils.getBR (src, dst)</strong>
    </dt>
    <dd>
    retrun Bearing (magnetic) and range between two points


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">src</span>
         (DCS pos) Position of source
        </li>
        <li><span class="parameter">dst</span>
         (DCS pos) Position of destination
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        (table) {br = bearing(float), brStr=bearing(string, 3 chars rounded, e.g "044"), rng = Range in NM}
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getFormationCallsign"></a>
    <strong>HOUND.Utils.getFormationCallsign (player[, flightMember])</strong>
    </dt>
    <dd>
    Get group callsign from unit


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">player</span>
         mist.DB entry to get formation callsign for
        </li>
        <li><span class="parameter">flightMember</span>
         if True. value returned will be the full callsign (i.e "Uzi 1 1" rather then the default "Uzi 1")
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Formation callsign string
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.getHoundCallsign"></a>
    <strong>HOUND.Utils.getHoundCallsign ([namePool])</strong>
    </dt>
    <dd>
    get Callsign


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">namePool</span>
         string "GENERIC" or "NATO"
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string random callsign from pool
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.isDMM"></a>
    <strong>HOUND.Utils.isDMM (DCS_Unit)</strong>
    </dt>
    <dd>
    Unit use DMM


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">DCS_Unit</span>
         DCS Unit or typeName string
        </li>
    </ul>





</dd>
    <dt>
    <a name = "HOUND.Utils.hasPayload"></a>
    <strong>HOUND.Utils.hasPayload (DCS_Unit, payloadName)</strong>
    </dt>
    <dd>
    does unit has payload (placeholder)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">DCS_Unit</span>
         DCS unit
        </li>
        <li><span class="parameter">payloadName</span>
         Name of payload
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool always true
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.hasTask"></a>
    <strong>HOUND.Utils.hasTask (DCS_Unit, taskName)</strong>
    </dt>
    <dd>
    does unit has task (placeholder)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">DCS_Unit</span>
         DCS unit
        </li>
        <li><span class="parameter">taskName</span>
         Name of task
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool always true
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Value_mapping_Functions"></a>Value mapping Functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Mapping.linear"></a>
    <strong>HOUND.Utils.Mapping.linear (input, in_min, in_max, out_min, out_max[, clamp])</strong>
    </dt>
    <dd>
    map input to range (Arduino implementation)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">input</span>
         value
        </li>
        <li><span class="parameter">in_min</span>
         Minimum allowble input value
        </li>
        <li><span class="parameter">in_max</span>
         Maximum allowable input value
        </li>
        <li><span class="parameter">out_min</span>
         Minimum allowable output value
        </li>
        <li><span class="parameter">out_max</span>
         Maximum allowable output value
        </li>
        <li><span class="parameter">clamp</span>
         Bool if true values will be clipped at range specified
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        calculated mapped value
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">HOUND.Utils.Mapping.linear(<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">100</span>) = <span class="number">100</span>
  HOUND.Utils.Mapping.linear(<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">100</span>) = <span class="number">50</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "HOUND.Utils.Mapping.nonLinear"></a>
    <strong>HOUND.Utils.Mapping.nonLinear (value, in_min, in_max[, out_min[, out_max[, sensitivity[, curve_type]]]])</strong>
    </dt>
    <dd>
    Map values on a curve


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         original input
        </li>
        <li><span class="parameter">in_min</span>
         Minimum input value
        </li>
        <li><span class="parameter">in_max</span>
         Maximum input value
        </li>
        <li><span class="parameter">out_min</span>
         Minimum output value (0 if not specified)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">out_max</span>
         Maximum output value (1 if not specified)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">sensitivity</span>
         requested sensitivity (0-9, default 9 is leased curved)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">curve_type</span>
         requested curve profile (0-6, 0 is default)
         (<em>optional</em>)
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="Geo_Function"></a>Geo Function </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Geo.checkLOS"></a>
    <strong>HOUND.Utils.Geo.checkLOS (pos0, pos1)</strong>
    </dt>
    <dd>
    Return if the is LOS between two DCS points
 checks both radar horizon (round earth) and DCS terrain LOS


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pos0</span>
         (DCS pos)
        </li>
        <li><span class="parameter">pos1</span>
         (DCS pos)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        (bool) true if both units have LOS between them
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Geo.EarthLOS"></a>
    <strong>HOUND.Utils.Geo.EarthLOS (h0[, h1])</strong>
    </dt>
    <dd>
    Returns maximum horizon distance given heigh above the earth of two points
 if only one observer hight is provided, result would be maximum view distance to Sea Level


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">h0</span>
         height of observer 1 in meters
        </li>
        <li><span class="parameter">h1</span>
         height of observer 2 in meters
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        distance maximum LOS distance in meters
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Geo.isDcsPoint"></a>
    <strong>HOUND.Utils.Geo.isDcsPoint (point)</strong>
    </dt>
    <dd>
    check if point is DCS point


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">point</span>
         DCS point candidate
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool True if is valid point
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Geo.getProjectedIP"></a>
    <strong>HOUND.Utils.Geo.getProjectedIP (p0, az, el)</strong>
    </dt>
    <dd>
    Returns Projected line impact point with Terrain


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">p0</span>
         source Postion
        </li>
        <li><span class="parameter">az</span>
         Azimuth from Position (radians)
        </li>
        <li><span class="parameter">el</span>
         Elevation angle from position (radians)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        DCS point of intersection with ground
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Geo.setPointHeight"></a>
    <strong>HOUND.Utils.Geo.setPointHeight (point)</strong>
    </dt>
    <dd>
    Ensure Inpoint DCS point has Elevation


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">point</span>
         DCS point
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Point but with elevation
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Geo.setHeight"></a>
    <strong>HOUND.Utils.Geo.setHeight (point)</strong>
    </dt>
    <dd>
    Ensure input point or point table all have valid Elevation


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">point</span>
         DCS point
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        same as input, but with elevation. will return original value if is not DCS point
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Marker_Functions"></a>Marker Functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Marker.getId"></a>
    <strong>HOUND.Utils.Marker.getId ()</strong>
    </dt>
    <dd>
    Get next Markpoint Id



    <h3>Returns:</h3>
    <ol>

        Next MarkId
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Marker.setInitialId"></a>
    <strong>HOUND.Utils.Marker.setInitialId (startId)</strong>
    </dt>
    <dd>
    Set New initial marker Id


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">startId</span>
         Number to start counting from
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool True if initial ID was updated
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Marker.create"></a>
    <strong>HOUND.Utils.Marker.create ([args])</strong>
    </dt>
    <dd>
    create Marker entity


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">args</span>
         parameters of markpoint
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Hound Marker Instance
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="HOUND_Utils_Marker_instance"></a>HOUND.Utils.Marker.instance</h2>

    <dl class="function">
    <dt>
    <a name = "instance.setPos"></a>
    <strong>instance.setPos (self, pos)</strong>
    </dt>
    <dd>
    update markpoint position


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
        <li><span class="parameter">pos</span>
         position of marker (only single point is supported)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "instance.setText"></a>
    <strong>instance.setText (self, text)</strong>
    </dt>
    <dd>
    update markpoint text


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
        <li><span class="parameter">text</span>
         new text for marker
        </li>
    </ul>





</dd>
    <dt>
    <a name = "instance.setRadius"></a>
    <strong>instance.setRadius (self, radius)</strong>
    </dt>
    <dd>
    update markpoint radius


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
        <li><span class="parameter">radius</span>
         new radius of markpoint (only circle type marks are supported)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "instance.setFillColor"></a>
    <strong>instance.setFillColor (self, color)</strong>
    </dt>
    <dd>
    update markpoint fill color


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
        <li><span class="parameter">color</span>
         new fill color of marker
        </li>
    </ul>





</dd>
    <dt>
    <a name = "instance.setLineColor"></a>
    <strong>instance.setLineColor (self, color)</strong>
    </dt>
    <dd>
    update markpoint line color


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
        <li><span class="parameter">color</span>
         new fill color of marker
        </li>
    </ul>





</dd>
    <dt>
    <a name = "instance.isDrawn"></a>
    <strong>instance.isDrawn (self)</strong>
    </dt>
    <dd>
    Check if marpoint is drawn


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool - True if marker is drawn
    </ol>




</dd>
    <dt>
    <a name = "instance.remove"></a>
    <strong>instance.remove (self)</strong>
    </dt>
    <dd>
    remove markpoint


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
    </ul>





</dd>
    <dt>
    <a name = "instance._new"></a>
    <strong>instance._new (self, args)</strong>
    </dt>
    <dd>
    create new point (internal)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
        <li><span class="parameter">args</span>
         full args array
        </li>
    </ul>





</dd>
    <dt>
    <a name = "instance._replace"></a>
    <strong>instance._replace (self, args)</strong>
    </dt>
    <dd>
    replace markpoint (internal)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
        <li><span class="parameter">args</span>
         full args array
        </li>
    </ul>





</dd>
    <dt>
    <a name = "instance.update"></a>
    <strong>instance.update (self, args)</strong>
    </dt>
    <dd>
    update markpoint


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         Hound Marker instance
        </li>
        <li><span class="parameter">args</span>
         full args array
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="TTS_Functions"></a>TTS Functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.TTS.Transmit"></a>
    <strong>HOUND.Utils.TTS.Transmit (msg, coalitionID, args[, transmitterPos])</strong>
    </dt>
    <dd>
    Transmit message using STTS (private)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">msg</span>
         The message to transmit
        </li>
        <li><span class="parameter">coalitionID</span>
         Coalition to recive transmission
        </li>
        <li><span class="parameter">args</span>
         STTS settings in hash table (minimum required is {freq=})
        </li>
        <li><span class="parameter">transmitterPos</span>
         DCS Position point for transmitter
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        STTS.TextToSpeech return value recived from STTS, currently estimated speechTime
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.TTS.getTtsTime"></a>
    <strong>HOUND.Utils.TTS.getTtsTime ([timestamp])</strong>
    </dt>
    <dd>
    returns current DCS time in military time string for TTS


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timestamp</span>
         DCS time in seconds (timer.getAbsTime()) - if not arg provided will return for current game time
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        timeString e.g. "14 30 local", "08 hundred local"
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.TTS.getVerbalConfidenceLevel"></a>
    <strong>HOUND.Utils.TTS.getVerbalConfidenceLevel (confidenceRadius)</strong>
    </dt>
    <dd>
    return verbal accuracy description
 in 500 meters interval


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">confidenceRadius</span>
         meters
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        (string) Description of accuracy e.g "Very High","High","Low"...
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.TTS.getVerbalContactAge"></a>
    <strong>HOUND.Utils.TTS.getVerbalContactAge (timestamp[, isSimple[, NATO]])</strong>
    </dt>
    <dd>
    Get Verbal description of contact age
 has multiple "modes of operation"


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timestamp</span>
         dcs time in seconds of last time a target was seen
        </li>
        <li><span class="parameter">isSimple</span>
         (bool) switch between output modes. true: "Active", "recent"... False: "3 seconds","5 minutes"
         (<em>optional</em>)
        </li>
        <li><span class="parameter">NATO</span>
         (bool) requires isSimple=true, will return only "Active" or "Awake" as per NATO Lowdown
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string of time passed based on selected flags.
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.TTS.getVerbalLL"></a>
    <strong>HOUND.Utils.TTS.getVerbalLL (lat, lon[, minDec])</strong>
    </dt>
    <dd>
    convert LL to TTS string


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">lat</span>
         Latitude in decimal degrees ("32.343","-14.44333")
        </li>
        <li><span class="parameter">lon</span>
         Longitude in decimal degrees ("42.343","-144.432")
        </li>
        <li><span class="parameter">minDec</span>
         (bool) if true, function will return LL in DM.M format
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        LL string.
 eg. "North, 33 degrees, 15 minutes, 12 seconds, East, 42 degrees, 10 minutes, 45 seconds "
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.TTS.toPhonetic"></a>
    <strong>HOUND.Utils.TTS.toPhonetic (str)</strong>
    </dt>
    <dd>
    Convert string to phonetic text


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">str</span>
         String to convert
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string broken up to phonetics
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">HOUND.Utils.TTS.toPhonetic(<span class="string">"B29"</span>) will <span class="keyword">return</span> <span class="string">"Bravo Two Niner"</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "HOUND.Utils.TTS.getReadTime"></a>
    <strong>HOUND.Utils.TTS.getReadTime (length[, speed[, isGoogle]])</strong>
    </dt>
    <dd>
    get estimated message read time
 returns estimated time in seconds STTS will need to read a message


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">length</span>
         length of string to estimate (also except the string itself)
        </li>
        <li><span class="parameter">speed</span>
         speed setting for reading them message
         (<em>optional</em>)
        </li>
        <li><span class="parameter">isGoogle</span>
         Bool, if true calculation will be done for GoogleTTS engine
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        estimated message read time in seconds
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.TTS.simplfyDistance"></a>
    <strong>HOUND.Utils.TTS.simplfyDistance (distanceM)</strong>
    </dt>
    <dd>
    simplify distance


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">distanceM</span>
         Distance in meters to simplify
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

         Simplified distance
 below 1km function will return number in meters
 eg. 140m => 150m, 520m => 500m, 4539m => 4.5km
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Text_Functions"></a>Text Functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Text.getLL"></a>
    <strong>HOUND.Utils.Text.getLL (lat, lon[, minDec])</strong>
    </dt>
    <dd>
    convert LL to displayable string


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">lat</span>
         Latitude in decimal degrees ("32.343","-14.44333")
        </li>
        <li><span class="parameter">lon</span>
         Longitude in decimal degrees ("42.343","-144.432")
        </li>
        <li><span class="parameter">minDec</span>
         (bool) if true, function will return LL in DM.M format
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        LL string.
 eg. "N33°15'12" E42°10'45"" or  "N33°15.200' E42°10.750'"
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Text.getTime"></a>
    <strong>HOUND.Utils.Text.getTime ([timestamp])</strong>
    </dt>
    <dd>
    Text Function - returns current DCS time in military time format string


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timestamp</span>
         DCS time in seconds (timer.getAbsTime()) - Optional, if not arg provided will return for current game time
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        time in human radable format e.g. "1430", "0812"
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Elint_functions"></a>Elint functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Elint.getDefraction"></a>
    <strong>HOUND.Utils.Elint.getDefraction (band, antenna_size)</strong>
    </dt>
    <dd>
    Get defraction
 for band and effective antenna size return angular resolution


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">band</span>
         Radar transmission band (A-L) as defined in HOUND.DBs
        </li>
        <li><span class="parameter">antenna_size</span>
         Effective antenna size for platform as defined in HOUND.DBs
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        angular resolution in Radians for Band Antenna combo
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Elint.getApertureSize"></a>
    <strong>HOUND.Utils.Elint.getApertureSize (DCS_Unit)</strong>
    </dt>
    <dd>
    get Effective Aperture size for unit


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">DCS_Unit</span>
         Unit requested (used as platform)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Effective aperture size in meters
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Elint.getEmitterBand"></a>
    <strong>HOUND.Utils.Elint.getEmitterBand (DCS_Unit)</strong>
    </dt>
    <dd>
    Get emitter Band


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">DCS_Unit</span>
         Radar unit
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Char radar band
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Elint.getSensorPrecision"></a>
    <strong>HOUND.Utils.Elint.getSensorPrecision (platform, emitterBand)</strong>
    </dt>
    <dd>
    Elint Function - Get sensor precision


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">platform</span>
         Instance of DCS Unit which is the detecting platform
        </li>
        <li><span class="parameter">emitterBand</span>
         Radar Band (frequency) of radar (A-L)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        angular resolution in Radians of platform against specific Radar frequency
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Elint.generateAngularError"></a>
    <strong>HOUND.Utils.Elint.generateAngularError (variance)</strong>
    </dt>
    <dd>
    Elint Function - Generate angular error


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">variance</span>
         amount of variance in gausian random function
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table {az,el} error in radians per element
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Elint.getAzimuth"></a>
    <strong>HOUND.Utils.Elint.getAzimuth (src, dst, sensorPrecision)</strong>
    </dt>
    <dd>
    Get Azimuth (and elevation) between two points


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">src</span>
         position of the source (i.e Hound platform)
        </li>
        <li><span class="parameter">dst</span>
         position of the destination (i.e emitting radar)
        </li>
        <li><span class="parameter">sensorPrecision</span>
         angular resolution (in rad) of platform against radar <a href="../modules/HOUND.Utils.html#HOUND.Utils.Elint.getSensorPrecision">HOUND.Utils.Elint.getSensorPrecision</a>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        Azimuth (radians) from source to destination (0 to 2*pi)</li>
        <li>
        elevation angle (radians) from source to destination (-pi to pi)</li>
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Elint.getActiveRadars"></a>
    <strong>HOUND.Utils.Elint.getActiveRadars (instanceCoalition)</strong>
    </dt>
    <dd>
    Get currently transmitting Ground and Ship radars that are not in the Hound Instance coalition


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">instanceCoalition</span>
         CoalitionID for current Hound Instance
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Table of all currently transmitting Ground and Ship radars that are not in the Hound Instance coalition
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Elint.getRwrContacts"></a>
    <strong>HOUND.Utils.Elint.getRwrContacts (platform)</strong>
    </dt>
    <dd>
    Get RWR contacts for platfom


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">platform</span>
         DCS Unit of platform
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Table of all currently transmitting Ground and Ship radars that RWR detected by supplied platform
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Elint.isValidPlatform"></a>
    <strong>HOUND.Utils.Elint.isValidPlatform (candidate)</strong>
    </dt>
    <dd>
    check if canidate Object is a valid platform


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">candidate</span>
         DCS Object (Unit or Static Object)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool. True if object is valid platform
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Vector_functions"></a>Vector functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Vector.getUnitVector"></a>
    <strong>HOUND.Utils.Vector.getUnitVector (Theta[, Phi])</strong>
    </dt>
    <dd>
    get UnitVector


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">Theta</span>
         azimuth in radians
        </li>
        <li><span class="parameter">Phi</span>
         elevation in radians
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Unit vector {x,y,z}
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Vector.getRandomVec2"></a>
    <strong>HOUND.Utils.Vector.getRandomVec2 (variance)</strong>
    </dt>
    <dd>
    Get random 2D vector
 use Box–Muller transform to randomize errors on 2D vector
 https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform}


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">variance</span>
         amount of variance in gausian random function
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        DCS standard {x,z,y} vector
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Vector.getRandomVec3"></a>
    <strong>HOUND.Utils.Vector.getRandomVec3 (variance)</strong>
    </dt>
    <dd>
    Get random 3d vector
 use Box–Muller transform to randomize errors on 3D vector
 https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform}


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">variance</span>
         amount of variance in gausian random function
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        DCS standard {x,z,y} vector
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Zone_functions"></a>Zone functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Zone.listDrawnZones"></a>
    <strong>HOUND.Utils.Zone.listDrawnZones ()</strong>
    </dt>
    <dd>
    List all Useable zones from drawings.
 (supported types are freeForm Polygon, rectangle and Oval)



    <h3>Returns:</h3>
    <ol>

        list of strings
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Zone.getDrawnZone"></a>
    <strong>HOUND.Utils.Zone.getDrawnZone (zoneName)</strong>
    </dt>
    <dd>
    Get zone from drawing\
 (supported types are freeForm Polygon, rectangle and Oval)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">zoneName</span>

        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table of points
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Polygon_functions"></a>Polygon functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Polygon.threatOnSector"></a>
    <strong>HOUND.Utils.Polygon.threatOnSector (polygon, point, radius)</strong>
    </dt>
    <dd>
    Check if polygon is under threat of SAM


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">polygon</span>
         Table of point reprasenting a polygon
        </li>
        <li><span class="parameter">point</span>
         DCS position (x,z)
        </li>
        <li><span class="parameter">radius</span>
         Radius in Meters around point to test
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        Bool True if point is in polygon</li>
        <li>
        Bool True if radius around point intersects polygon</li>
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Polygon.filterPointsByPolygon"></a>
    <strong>HOUND.Utils.Polygon.filterPointsByPolygon (points, polygon)</strong>
    </dt>
    <dd>
    Filter out points not in polygon


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">points</span>
         Points to filter
        </li>
        <li><span class="parameter">polygon</span>
         - enclosing polygon to filter by
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        points from original set which are inside polygon.
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Polygon.clipPolygons"></a>
    <strong>HOUND.Utils.Polygon.clipPolygons (subjectPolygon, clipPolygon)</strong>
    </dt>
    <dd>
    calculate cliping of polygons
 <a href="https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#Lua">Sutherland-Hodgman polygon clipping</a>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">subjectPolygon</span>
         List of points of first polygon
        </li>
        <li><span class="parameter">clipPolygon</span>
         list of points of second polygon
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        List of points of the clipped polygon or nil if not clipping found
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Polygon.giftWrap"></a>
    <strong>HOUND.Utils.Polygon.giftWrap (points)</strong>
    </dt>
    <dd>
    Gift wrapping algorithem
 Returns the convex hull (using <a href="http://en.wikipedia.org/wiki/Gift_wrapping_algorithm">Jarvis' Gift wrapping algorithm</a>).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">points</span>
         array of DCS points ({x=&ltvalue&gt,z=&ltvalue&gt})
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the convex hull as an array of points
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Polygon.circumcirclePoints"></a>
    <strong>HOUND.Utils.Polygon.circumcirclePoints (points)</strong>
    </dt>
    <dd>
    calculate Smallest circle around point cloud
 Welzel algorithm for <a href="https://en.wikipedia.org/wiki/Smallest-circle_problem">Smallest-circle problem</a>
 Implementation taken from <a href="https://github.com/rowanwins/smallest-enclosing-circle/blob/master/src/main.js">github/rowins</a>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">points</span>
         Table containing cloud points
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Circle {x=&ltCenter X&gt,z=&ltCenter Z&gt, y=&ltLand height at XZ&gt,r=&ltradius in meters&gt}
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Polygon.getArea"></a>
    <strong>HOUND.Utils.Polygon.getArea (polygon)</strong>
    </dt>
    <dd>
    return the area of a convex polygon


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">polygon</span>
         list of DCS points
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        area of polygon
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Polygon.clipOrHull"></a>
    <strong>HOUND.Utils.Polygon.clipOrHull (polyA, polyB)</strong>
    </dt>
    <dd>
    clip or hull two polygons


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">polyA</span>
         polygon
        </li>
        <li><span class="parameter">polyB</span>
         polygon
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Polygon which is clip or convexHull of the two input polygons
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Polygon.azMinMax"></a>
    <strong>HOUND.Utils.Polygon.azMinMax (poly, refPos)</strong>
    </dt>
    <dd>
    find min/max azimuth


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">poly</span>
         Polygon
        </li>
        <li><span class="parameter">refPos</span>
         DCS point to calculate from
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        deltaMinMax delta angle between the two extream points</li>
        <li>
        minAz (rad)</li>
        <li>
        maxAz (rad)</li>
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Clustering_algorithems__for_future_use_"></a>Clustering algorithems (for future use) </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Cluster.gaussianKernel"></a>
    <strong>HOUND.Utils.Cluster.gaussianKernel (value, bandwidth)</strong>
    </dt>
    <dd>
    Get gaussian weight


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         input to evaluate
        </li>
        <li><span class="parameter">bandwidth</span>
         Standard diviation for weight calculation
        </li>
    </ul>





</dd>
    <dt>
    <a name = "HOUND.Utils.Cluster.stdDev"></a>
    <strong>HOUND.Utils.Cluster.stdDev ()</strong>
    </dt>
    <dd>
    Calculate running std dev



    <h3>Returns:</h3>
    <ol>

        std calc instance
 https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Cluster.weightedMean"></a>
    <strong>HOUND.Utils.Cluster.weightedMean (origPoints[, initPos[, threashold[, maxIttr]]])</strong>
    </dt>
    <dd>
    find the weighted mean of a points cluster (meanShift)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">origPoints</span>
         DCS points cluster
        </li>
        <li><span class="parameter">initPos</span>
         externally provided initial mean (DCS Point)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">threashold</span>
         distance in meters below with solution is considered converged (default 1m)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">maxIttr</span>
         Max itterations from converging solution (default 100)
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        DCS point of the cluster weighted mean
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Cluster.kmeans"></a>
    <strong>HOUND.Utils.Cluster.kmeans (data, nclusters, init)</strong>
    </dt>
    <dd>
    K-means++ algorithm
 <a href=https://rosettacode.org/wiki/K-means%2B%2B_clustering#Lua>Source of implementation</a>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         Datapoints
        </li>
        <li><span class="parameter">nclusters</span>
         Number of clusters to create
        </li>
        <li><span class="parameter">init</span>
         Initilization method. Valid values are ["kmeans++","random"]
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        centers (table)</li>
        <li>
        cluster (table)</li>
        <li>
        J loss value</li>
    </ol>




</dd>
    <dt>
    <a name = "contacts"></a>
    <strong>contacts</strong>
    </dt>
    <dd>
    convert contacts to centroieds for meanShift


    <ul>
        <li><span class="parameter">contacts</span>
         list of HOUND.Contact instances to evaluate
        </li>
    </ul>





</dd>
    <dt>
    <a name = "contacts"></a>
    <strong>contacts</strong>
    </dt>
    <dd>
    Mean-shift algorithem to group radars to sites
 http://www.chioka.in/meanshift-algorithm-for-the-rest-of-us-python/


    <ul>
        <li><span class="parameter">contacts</span>
         list of HOUND.Contact instances to cluster
        </li>
        <li><span class="parameter">iterations</span>
         maximum nuber of itteratoins to run
         (<em>optional</em>)
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="Sort_Functions"></a>Sort Functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Sort.ContactsByRange"></a>
    <strong>HOUND.Utils.Sort.ContactsByRange (a, b)</strong>
    </dt>
    <dd>
    Sort contacts by engament range


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         <a href="../modules/HOUND.Contact.html#">HOUND.Contact</a> instance
        </li>
        <li><span class="parameter">b</span>
         <a href="../modules/HOUND.Contact.html#">HOUND.Contact</a> Instance
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">table</span>.sort(unSorted,HOUND.Utils.Sort.ContactsByRange)</pre>
    </ul>

</dd>
    <dt>
    <a name = "HOUND.Utils.Sort.ContactsById"></a>
    <strong>HOUND.Utils.Sort.ContactsById (a, b)</strong>
    </dt>
    <dd>
    Sort contacts by ID


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         <a href="../modules/HOUND.Contact.html#">HOUND.Contact</a> instance
        </li>
        <li><span class="parameter">b</span>
         <a href="../modules/HOUND.Contact.html#">HOUND.Contact</a> Instance
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">table</span>.sort(unSorted,HOUND.Utils.Sort.ContactsById)</pre>
    </ul>

</dd>
    <dt>
    <a name = "HOUND.Utils.Sort.sectorsByPriorityLowFirst"></a>
    <strong>HOUND.Utils.Sort.sectorsByPriorityLowFirst (a, b)</strong>
    </dt>
    <dd>
    sort sectors by priority (low first)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         <a href="../modules/HOUND.Sector.html#">HOUND.Sector</a> instance
        </li>
        <li><span class="parameter">b</span>
         <a href="../modules/HOUND.Sector.html#">HOUND.Sector</a> Instance
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">table</span>.sort(unSorted,HOUND.Utils.Sort.sectorsByPriorityLowFirst)</pre>
    </ul>

</dd>
    <dt>
    <a name = "HOUND.Utils.Sort.sectorsByPriorityLowLast"></a>
    <strong>HOUND.Utils.Sort.sectorsByPriorityLowLast (a, b)</strong>
    </dt>
    <dd>
    sort sectors by priority (Low last)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         <a href="../modules/HOUND.Sector.html#">HOUND.Sector</a> instance
        </li>
        <li><span class="parameter">b</span>
         <a href="../modules/HOUND.Sector.html#">HOUND.Sector</a> Instance
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Bool
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">table</span>.sort(unSorted,HOUND.Utils.Sort.sectorsByPriorityLowLast)</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Filter_Functions"></a>Filter Functions </h2>

    <dl class="function">
    <dt>
    <a name = "HOUND.Utils.Filter.groupsByPrefix"></a>
    <strong>HOUND.Utils.Filter.groupsByPrefix (prefix)</strong>
    </dt>
    <dd>
    get Groups by prefix
 Implementation taken from Skynet-IADS


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">prefix</span>
         string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table of DCS groups indexed by group name
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Filter.unitsByPrefix"></a>
    <strong>HOUND.Utils.Filter.unitsByPrefix (prefix)</strong>
    </dt>
    <dd>
    get Units by prefix
 Implementation taken from Skynet-IADS


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">prefix</span>
         string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table of DCS Units indexed by Unit name
    </ol>




</dd>
    <dt>
    <a name = "HOUND.Utils.Filter.staticObjectsByPrefix"></a>
    <strong>HOUND.Utils.Filter.staticObjectsByPrefix (prefix)</strong>
    </dt>
    <dd>
    get StatcObjects by prefix
 Implementation taken from Skynet-IADS


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">prefix</span>
         string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table of DCS StaticObjects indexed by object name
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2022-05-21 23:51:09 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
